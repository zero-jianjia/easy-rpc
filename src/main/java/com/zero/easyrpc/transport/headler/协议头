/**
    * **************************************************************************************************
    *                                          Protocol
    *  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
    *       2   │   1   │    1   │     8     │      4      │
    *  ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤
    *           │       │        │           │             │
    *  │  MAGIC   Sign    Status   Invoke Id   Body Length                   Body Content              │
    *           │       │        │           │             │
    *  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
    *
    * 消息头16个字节定长
    * = 2 // MAGIC = (short) 0xbabe
    * + 1 // 消息标志位, 用来表示消息类型
    * + 1 // 空
    * + 8 // 消息 id long 类型
    * + 4 // 消息体body长度, int类型
    */

上述的两种方案是很便捷，也很好实现的方案，Netty也对这两种方法给出了直接的解决方案，但是在我们这个RPC框架下，还是借鉴了TCP的一些协议的思想：
1）比如我们可以规定一个协议头，协议头的第一部分是一个Mark，也就是我们俗称的头标志位，表示该信息是本端口需要接受的信息，如果不是则丢弃
2）然后再来有一个sign，来表示这个消息的内容是什么，是Student，Teacher，还是其他的云云
3）接着再加一个ReuqestId，为什么需要一个请求Id呢？其实很好理解，因为Netty可以认为是双向通信的，假如某个场景下，当Client端发送100次请求，Server端需要对这100次请求一一作出响应的时候，就可以用这个ReuqestId将Request/Response一一对应上，因为网络发送的是异步的，也不保证顺序，也存在丢包的可能，所以先发的响应未必先到，所以有了ReuqestId这样就会防止这种问题
4）协议头的最后一部分信息，就是主题的字节长度，Body Length，这样我们就知道我们接下来再读多少个字节就能获取完整的一段信息了
5）主体部分的信息，Body